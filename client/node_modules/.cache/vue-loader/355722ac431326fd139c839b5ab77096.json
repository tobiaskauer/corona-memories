{"remainingRequest":"/Users/tk/GitHub/corona-memories/client/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/tk/GitHub/corona-memories/client/src/components/vis.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/tk/GitHub/corona-memories/client/src/components/vis.vue","mtime":1615567622705},{"path":"/Users/tk/GitHub/corona-memories/client/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/corona-memories/client/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/tk/GitHub/corona-memories/client/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/corona-memories/client/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBWdWUgZnJvbSAndnVlJwppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycKLy9pbXBvcnQge2Fubm90YXRpb24sIGFubm90YXRpb25DYWxsb3V0fSBmcm9tICJkMy1zdmctYW5ub3RhdGlvbiIKaW1wb3J0IGxpbmVzIGZyb20gJy4vbGluZXMnCgpleHBvcnQgZGVmYXVsdCB7CiAgY29tcG9uZW50czogewogICAgbGluZXMsCiAgfSwKICBkYXRhICgpIHsKICAgIHJldHVybiB7CiAgICAgIHBhcnNlRGF0ZTogZDMudXRjUGFyc2UoIiVZLSVtLSVkIiksCiAgICAgIGZvcm1hdERhdGU6IGQzLnRpbWVGb3JtYXQoIiVZLSVtLSVkIiksCiAgICAgIGxpbmVHZW5lcmF0b3I6IGQzLmxpbmUoKS54KGQgPT4gZC54KS55KGQgPT4gZC55KS5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKSwKICAgICAgbW91bnRlZDogZmFsc2UsCiAgICAgIGZvcmNlOiBudWxsLAogICAgICBvcGFjaXR5OiAwLjgsIC8vY2lyY2xlIG9wYWNpdHkgd2hlbiBub3QgaG92ZXJlZAogICAgICBmb3JjZURpc3RhbmNlOiA4LCAvL2Rpc3RhbmNlIG9mIHJlYWN0aW9ucyB0byBsaW5lCiAgICAgIGN1cnJlbnRNZW1vcnk6IG51bGwsIC8vd2hlbiBjdXJyZW50bHkgZGlzcGxheWluZyBhIG1lbW9yeSwgcGljayB0aGUgcmlnaHQgb25lIHRvIGhpZ2hsaWdodAogICAgICBuZXdNZW1vcnk6IHsKICAgICAgICBkYXRlOiBudWxsLAogICAgICAgIHNob3c6IGZhbHNlLAogICAgICAgIHBvc2l0aW9uOiB7eDogLTEwMCwgeTogLTEwMH0sIC8vc3RhcnQgb3V0IG9mIHNpZ2h0CiAgICAgIH0sCiAgICB9CiAgfSwKCiAgcHJvcHM6IHsKICAgIG9wdGlvbnM6IE9iamVjdCwKICAgIGhhc2h0YWc6IFN0cmluZywKICAgIGNhc2VzOiBBcnJheSwKICAgIG1lbW9yaWVzOiBBcnJheSwKICAgIGRhdGVQaWNrZXI6IEJvb2xlYW4sCgogIH0sCgogIGNvbXB1dGVkOiB7CiAgICBwYXJzZWRDYXNlczogZnVuY3Rpb24oKSB7CiAgICAgIHJldHVybiB0aGlzLmNhc2VzLm1hcCgoYykgPT4gewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkYXRlU3RyaW5nOiBjLmQsCiAgICAgICAgICBkYXRlOiB0aGlzLnBhcnNlRGF0ZShjLmQpLAogICAgICAgICAgdmFsdWU6IGMudiwKICAgICAgICB9CiAgICAgIH0pCiAgICB9LAoKICAgIHNjYWxlczogZnVuY3Rpb24oKSB7CiAgICAgIGlmKCF0aGlzLnBhcnNlZENhc2VzICYmIHRoaXMubWVtb3JpZXMpIHJldHVybiBudWxsCgogICAgICBsZXQgeURvbWFpbiA9IFswLGQzLm1heChbNTAsZDMubWF4KHRoaXMucGFyc2VkQ2FzZXMsIGQ9PmQudmFsdWUpXSldIC8vbWluaW11bSBvZiA1MCBjYXNlcyB0byBoYXZlIGEgc29tZXdoYXQgY29uc2lzdGVudCBsYXlvdXQKICAgICAgbGV0IHhEb21haW4gPSBkMy5leHRlbnQodGhpcy5wYXJzZWRDYXNlcywgZD0+ZC5kYXRlKQogICAgICBsZXQgcmFkaXVzRG9tYWluID0gZDMuZXh0ZW50KHRoaXMubWVtb3JpZXMsIGQ9PmQud2VpZ2h0KQoKICAgICAgbGV0IHggPSBkMy5zY2FsZVRpbWUoKS5kb21haW4oeERvbWFpbikucmFuZ2UoW3RoaXMub3B0aW9ucy5kaW1lbnNpb25zLmxlZnQsdGhpcy5vcHRpb25zLmRpbWVuc2lvbnMud2lkdGgtdGhpcy5vcHRpb25zLmRpbWVuc2lvbnMucmlnaHRdKQogICAgICBsZXQgeSA9IGQzLnNjYWxlTGluZWFyKCkuZG9tYWluKHlEb21haW4pLnJhbmdlKFt0aGlzLm9wdGlvbnMuZGltZW5zaW9ucy5oZWlnaHQtdGhpcy5vcHRpb25zLmRpbWVuc2lvbnMuYm90dG9tLXRoaXMub3B0aW9ucy5kaW1lbnNpb25zLnRvcCx0aGlzLm9wdGlvbnMuZGltZW5zaW9ucy50b3BdKQogICAgICBsZXQgcmFkaXVzID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4ocmFkaXVzRG9tYWluKS5yYW5nZShbMiw2XSkKICAgICAgCiAgICAgIHJldHVybiB7eDogeCwgeTogeSwgcmFkaXVzOiByYWRpdXN9CiAgICB9LAoKICAgIHBhcnNlZE1lbW9yaWVzOiBmdW5jdGlvbigpIHsKICAgICAgaWYoIXRoaXMubWVtb3JpZXMpIHJldHVybiBudWxsCgogICAgICB0aGlzLnNjYWxlcyAvL21lbnRpb24gdG8gZm9yY2UgcmVjb21wdXRhdGlvbiBpZiBkaW1lbnNpb25zIGNoYW5nZQoKICAgICAgcmV0dXJuIHRoaXMubWVtb3JpZXMubWFwKChtZW1vcnksaSkgPT4gewogICAgICAgIGxldCBzaWduID0gKGklMikgPyAxIDogLTEKICAgICAgICBtZW1vcnkuRGF0ZSA9IHRoaXMucGFyc2VEYXRlKG1lbW9yeS5kYXRlKQogICAgICAgIG1lbW9yeS54ID0gdGhpcy5zY2FsZXMueChtZW1vcnkuRGF0ZSkKICAgICAgICBtZW1vcnkudmFsdWUgPSB0aGlzLmdldExpbmVFbGVtZW50KG1lbW9yeS5kYXRlKS52YWx1ZQogICAgICAgIG1lbW9yeS55ID0gdGhpcy5zY2FsZXMueShtZW1vcnkudmFsdWUpICsgdGhpcy5mb3JjZURpc3RhbmNlICogc2lnbgogICAgICAgIG1lbW9yeS5yYWRpdXMgPSB0aGlzLnNjYWxlcy5yYWRpdXMobWVtb3J5LndlaWdodCkKICAgICAgICBtZW1vcnkuaGFzaHRhZyA9IChtZW1vcnkuY29tbWVudC5tYXRjaCgvI1thLXpdKy9naSkpID8gKG1lbW9yeS5jb21tZW50Lm1hdGNoKC8jW2Etel0rL2dpKSlbMF0gOiBudWxsIAoKICAgICAgICByZXR1cm4gbWVtb3J5CiAgICAgIH0pCiAgICB9LAoKICAgIC8vZ2VuZXJhdGUgZm9yY2UgZGlyZWN0ZWQgaGFzaHRhZ3Mgb2YgWCBtb3N0IHdlaWdodGVuZWQgbGFiZWxzCiAgICBoYXNodGFnTGFiZWxzKCkgewogICAgICBpZighdGhpcy5tZW1vcmllcykgcmV0dXJuIG51bGwKICAgICAgdGhpcy5zY2FsZXMgLy9tZW50aW9uIHRvIGZvcmNlIHJlY29tcHV0YXRpb24gaWYgZGltZW5zaW9ucyBjaGFuZ2UKCiAgICAgIGxldCBub2RlcyA9IFtdCiAgICAgIGxldCBsaW5rcyA9IFtdIC8vCgogICAgICBsZXQgbWVtb3JpZXNXaXRoVGFncyA9IHRoaXMubWVtb3JpZXMuZmlsdGVyKG1lbW9yeSA9PiBtZW1vcnkuaGFzaHRhZyAmJiAhbWVtb3J5LmluYWN0aXZlKSAvL2FsbCBhY3RpdmUgbWVtb3JpZXMgdGhhdCBoYXZlIGhhc2h0YWdzCiAgICAgIAogICAgICBsZXQgbGF0ZXN0SGFzaHRhZyA9IFsuLi5tZW1vcmllc1dpdGhUYWdzXS5zb3J0KChhLGIpID0+IGIuRGF0ZSAtIGEuRGF0ZSlbMF0gLy90aGUgbGF0ZXN0IG1lbW9yeSB0aGF0IGhhcyBhIGhhc2h0YWcKICAgICAgbGV0IHNlbGVjdGVkVGFncyA9IG1lbW9yaWVzV2l0aFRhZ3Muc29ydCgoYSxiKSA9PiBiLndlaWdodCAtIGEud2VpZ2h0KS5zbGljZSgwLDEwKSAvL3RoZSBYIG1vc3Qgd2VpZ2h0ZW5lZCBsYWJlbHMKICAgICAgc2VsZWN0ZWRUYWdzLnB1c2gobGF0ZXN0SGFzaHRhZykgLy90aGUgbmV3ZXN0IG9uZSAodG8gcHV0IHRoZW0gaW50byB0aGUgdmlldykKCiAgICAgIHNlbGVjdGVkVGFncy5mb3JFYWNoKChtZW1vcnksaSkgPT4geyAvL2NyZWF0ZSBub2RlLWxpbmsgZGF0YQogICAgICAgICAgbm9kZXMucHVzaCh7dHlwZTogImNpcmNsZSIsIGZ4OiBtZW1vcnkueCwgZnk6IG1lbW9yeS55fSkgLy9vcmlnaW4KICAgICAgICAgIG5vZGVzLnB1c2goe3R5cGU6ICJsYWJlbCIsIHRleHQ6IG1lbW9yeS5oYXNodGFnfSkgLy90YXJnZXQKICAgICAgICAgIGxpbmtzLnB1c2goe3NvdXJjZTogaSoyLCB0YXJnZXQ6IGkqMisxfSkgLy9saW5rIHRoZSB0d28KICAgICAgICB9KQoKICAgICAgICB2YXIgc2ltdWxhdGlvbiA9IGQzLmZvcmNlU2ltdWxhdGlvbihub2RlcykgLy9nZW5lcmF0ZSBmb3JjZSBkaXJlY3RlZCBzaW11bGF0aW9uCiAgICAgICAgLmZvcmNlKCdjaGFyZ2UnLCBkMy5mb3JjZU1hbnlCb2R5KCkuc3RyZW5ndGgoLTApKQogICAgICAgIC5mb3JjZSgnbGluaycsIGQzLmZvcmNlTGluaygpLmxpbmtzKGxpbmtzKSkKICAgICAgICAvLy5mb3JjZSgnZm9yY2VZJywgZDMuZm9yY2VZKCkpCiAgICAgICAgLmZvcmNlKCdjb2xsaWRlJywgZDMuZm9yY2VDb2xsaWRlKG5vZGUgPT4ge3JldHVybiAobm9kZS50ZXh0KSA/IG5vZGUudGV4dC5sZW5ndGggKiAyIDogNTB9KSkKCiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8PSAyMDA7IGkrKykgewogICAgICAgICAgc2ltdWxhdGlvbi50aWNrKCkKICAgICAgICB9CgogICAgICAgIGxpbmtzLmZvckVhY2gobGluayA9PiB7CiAgICAgICAgICBsaW5rLnRhcmdldC5hbmNob3IgPSAobGluay50YXJnZXQueCA+IGxpbmsuc291cmNlLngpID8gInN0YXJ0IiA6ICJlbmQiCiAgICAgICAgfSkKICAgICAgcmV0dXJuIGxpbmtzCgogICAgfSwKICB9LAoKICB3YXRjaDogewogICAgcGFyc2VkTWVtb3JpZXM6IGZ1bmN0aW9uKG1lbW9yaWVzKSB7CiAgICAgIHRoaXMucmVsZWFzZVRoZUJlZXMobWVtb3JpZXMpCiAgIH0sCgogICAgaGFzaHRhZzogZnVuY3Rpb24obmV3SGFzaHRhZyl7CiAgICAgIGlmKCF0aGlzLm1lbW9yaWVzKSByZXR1cm4gbnVsbAogICAgICB0aGlzLm1lbW9yaWVzLmZvckVhY2goKG1lbW9yeSxpKSA9PiB7CiAgICAgICAgaWYobmV3SGFzaHRhZyAmJiAhbWVtb3J5LmNvbW1lbnQuaW5jbHVkZXMobmV3SGFzaHRhZykpIHsKICAgICAgICAgIFZ1ZS5zZXQodGhpcy5tZW1vcmllc1tpXSwnaW5hY3RpdmUnLHRydWUpCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIFZ1ZS5zZXQodGhpcy5tZW1vcmllc1tpXSwnaW5hY3RpdmUnLGZhbHNlKQogICAgICAgIH0KICAgICAgfSkKICAgIH0sCgogICAgbWVtb3JpZXM6IGZ1bmN0aW9uKGFycikgeyAvL3Nob3cgY2lyY2xlIG9uIG92ZXJsYXkgYWZ0ZXIgYmVlc3dhcm0gY2hhbmdlZAogICAgICBsZXQgYyA9IGFyci5maWx0ZXIoZT0+ZS5hY3RpdmUpWzBdCiAgICAgIGlmKGMpIHsKICAgICAgICB0aGlzLmN1cnJlbnRNZW1vcnkgPSBjCiAgICAgICAgIHRoaXMuY3VycmVudE1lbW9yeS5jb25uZWN0b3IgPSBgCiAgICAgICAgICBNJHtjLnh9ICR7Yy55fQogICAgICAgICAgUSR7KHRoaXMub3B0aW9ucy5kaW1lbnNpb25zLndpZHRoLzIpfSAke2MueX0KICAgICAgICAgICR7KHRoaXMub3B0aW9ucy5kaW1lbnNpb25zLndpZHRoLzIpfSAkeygxMCl9YDsKICAgICAgfQogICAgfQogIH0sCgogIGFzeW5jIG1vdW50ZWQoKSB7CiAgICB0aGlzLnJlbGVhc2VUaGVCZWVzKHRoaXMubWVtb3JpZXMpCiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uTW91c2VNb3ZlKQogICAgdGhpcy5tb3VudGVkID0gdHJ1ZTsKICB9LAoKICBtZXRob2RzOiB7CiAgICByZWxlYXNlVGhlQmVlczogZnVuY3Rpb24obWVtb3JpZXMpIHsKICAgICAgCiAgICAgIHRoaXMuZm9yY2UgPSBkMy5mb3JjZVNpbXVsYXRpb24obWVtb3JpZXMpCiAgICAgIC5mb3JjZSgnZm9yY2VYJywgZDMuZm9yY2VYKG1lbW9yeSA9PiBtZW1vcnkueCkuc3RyZW5ndGgoLjEpKQogICAgICAuZm9yY2UoJ2ZvcmNlWScsIGQzLmZvcmNlWShtZW1vcnkgPT4gbWVtb3J5LnkpLnN0cmVuZ3RoKC4xKSkKICAgICAgLmZvcmNlKCdjb2xsaWRlJywgZDMuZm9yY2VDb2xsaWRlKGQgPT4gZC5yYWRpdXMgKyAuNSkpCgogICAgICBmb3IobGV0IGkgPSAwOyBpIDw9IDIwOyBpKyspIHsKICAgICAgICB0aGlzLmZvcmNlLnRpY2soKQogICAgICB9CiAgICB9LAoKICAgIGhvdmVyOiBmdW5jdGlvbihtZW1vcnksZXZlbnQpIHsgLy9ob3ZlcmluZyBjaXJjbGVzCiAgICAgIGlmKCF0aGlzLmRhdGVQaWNrZXIpIHsgIC8vZGlzYWJsZSBob3ZlciB3aGVuIG1lbW9yeSBhZGRpbmcgaXMgaW4gcHJvZ3Jlc3MKICAgICAgICBsZXQgciA9IDEwCiAgICAgICAgbGV0IG9wYWNpdHkgPSAxCiAgICAgICAgaWYoZXZlbnQudHlwZSA9PSAnbW91c2VvdXQnKSB7CiAgICAgICAgICByID0gbWVtb3J5LndlaWdodAogICAgICAgICAgb3BhY2l0eSA9IHRoaXMub3BhY2l0eQogICAgICAgfQogICAgICAgZDMuc2VsZWN0KGV2ZW50LnRhcmdldCkudHJhbnNpdGlvbigiNTAiKS5hdHRyKCJyIixyKS5hdHRyKCJvcGFjaXR5IixvcGFjaXR5KQogICAgICB9CiAgICB9LAoKICAgIGdldExpbmVFbGVtZW50OiBmdW5jdGlvbihkYXRlU3RyaW5nKSB7CiAgICAgIGxldCB2YWx1ZU9uTWVtb3J5RGF0ZSA9IHRoaXMucGFyc2VkQ2FzZXMuZmluZChjID0+IGRhdGVTdHJpbmcgPT0gYy5kYXRlU3RyaW5nKQogICAgICByZXR1cm4gdmFsdWVPbk1lbW9yeURhdGUgPyB2YWx1ZU9uTWVtb3J5RGF0ZSA6IG51bGwKICAgIH0sCgogICAgZ2V0TGluZVNlZ21lbnQ6IGZ1bmN0aW9uKHN0YXJ0RGF0ZSxlbmREYXRlKSB7CiAgICAgIHN0YXJ0RGF0ZSA9ICh0eXBlb2Ygc3RhcnREYXRlID09PSAnc3RyaW5nJykgPyB0aGlzLnBhcnNlRGF0ZShzdGFydERhdGUpIDogc3RhcnREYXRlCiAgICAgIGVuZERhdGUgPSAodHlwZW9mIGVuZERhdGUgPT09ICdzdHJpbmcnKSA/IHRoaXMucGFyc2VEYXRlKGVuZERhdGUpIDogZW5kRGF0ZQogICAgICBsZXQgc2VnbWVudCA9IHRoaXMucGFyc2VkQ2FzZXMuZmlsdGVyKGMgPT4gLy9nZXQgcGFydHMgb2YgdGhlIGNhc2VMaW5lIHRoYXQgbWF0Y2ggY3VycmVudCBkYXRlcwogICAgICAgICAgICAoYy5kYXRlIDwgZW5kRGF0ZSAmJiBjLmRhdGUgPiBzdGFydERhdGUpIC8vZm9yd2FyZCBtb3ZlbWVudAogICAgICAgICAgICB8fCAoYy5kYXRlID4gZW5kRGF0ZSAmJiBjLmRhdGUgPCBzdGFydERhdGUpIC8vYmFja3dhcmQgbW92ZW1lbnQKICAgICAgICAgICkKICAgICAgcmV0dXJuIHNlZ21lbnQKICAgIH0sCgogICAgZ2V0Um91Z2hEYXRlOiBmdW5jdGlvbihkYXRlKSB7CiAgICAgIGlmKCFkYXRlKSByZXR1cm4gbnVsbAogICAgICAKICAgICAgbGV0IHJvdWdoID0gIkxhdGUiCiAgICAgIGlmKGRhdGUuZ2V0RGF0ZSgpIDw9IDIwKSByb3VnaCA9ICJNaWQiCiAgICAgIGlmKGRhdGUuZ2V0RGF0ZSgpIDw9IDEwKSByb3VnaCA9ICJFYXJseSIKICAgICAgbGV0IG1vbnRoID0gWyJKYW51YXJ5IiwgIkZlYnJ1YXJ5IiwgIk1hcmNoIiwgIkFwcmlsIiwgIk1heSIsICJKdW5lIiwgIkp1bHkiLCAiQXVndXN0IiwgIlNlcHRlbWJlciIsICJPY3RvYmVyIiwgIk5vdmVtYmVyIiwgIkRlY2VtYmVyIl1bZGF0ZS5nZXRNb250aCgpXQogICAgICAgIAogICAgICByZXR1cm4gcm91Z2grIiAiK21vbnRoCiAgICB9LAoKICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihldmVudCkgeyAvL2ZvbGxvdyBsaW5lCiAgICAgIGlmKHRoaXMuZGF0ZVBpY2tlcikgewogICAgICAgIGlmKGV2ZW50LmNsaWVudFggPiB0aGlzLnNjYWxlcy54LnJhbmdlKClbMF0gJiYgZXZlbnQuY2xpZW50WCA8IHRoaXMuc2NhbGVzLngucmFuZ2UoKVsxXSkgeyAvL2NoZWNrIHdoZXRoZXIgd2UgYXJlIG1vdmluZyB3aXRoaW4gdmlzIGJvdW5kYXJpZXMgdG8gYXZvaWQgZXJyb3JzCiAgICAgICAgICBsZXQgZGF0ZSA9IHRoaXMuc2NhbGVzLnguaW52ZXJ0KGV2ZW50LmNsaWVudFgpCiAgICAgICAgICBsZXQgZGF0ZVN0cmluZyA9IHRoaXMuZm9ybWF0RGF0ZShkYXRlKQogICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5zY2FsZXMueSh0aGlzLmdldExpbmVFbGVtZW50KGRhdGVTdHJpbmcpLnZhbHVlKQogICAgICAgICAgVnVlLnNldCh0aGlzLm5ld01lbW9yeSwnZGF0ZScsZGF0ZSkgLy9hbHNvIG1vdmUgY2lyY2xlCiAgICAgICAgICBWdWUuc2V0KHRoaXMubmV3TWVtb3J5LnBvc2l0aW9uLCd4JyxldmVudC5jbGllbnRYKSAvL2Fsc28gbW92ZSBjaXJjbGUKICAgICAgICAgIFZ1ZS5zZXQodGhpcy5uZXdNZW1vcnkucG9zaXRpb24sJ3knLHZhbHVlKQogICAgICAgIH0KICAgICAgfQogICAgfSwKICB9LAoKICAvKnVwZGF0ZWQ6IGZ1bmN0aW9uKCkgewogICAgY29uc29sZS5sb2coImZvbyIpCiAgICAgIHRoaXMuZm9yY2UudGljaygpCiAgfSwqLwp9Cg=="},{"version":3,"sources":["vis.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"vis.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <svg :width=\"options.dimensions.width\" :height=\"options.dimensions.height\" v-if=\"mounted\" z-index=\"5\">\n    \n    <lines\n      :dimensions=\"options.dimensions\"\n      :scales=\"scales\"\n      :cases=\"parsedCases\" />\n\n    <g v-if=\"force\" class=\"memories\"  transform=\"translate(0,0)\"> <!-- can go to component, actually.... -->\n      <circle\n        v-for=\"circle, i in parsedMemories.filter((e,i) => i < options.progress)\" :key=\"'circle-'+i\"\n        :cx=\"circle.x\"\n        :cy=\"circle.y\"\n        :class=\"{inactive: circle.inactive}\"\n        :r=\"circle.radius\"\n        fill=\"#FA5E2D\"\n        :opacity=\"opacity\"\n        @click=\"$emit('showMemory',circle)\"\n        @mouseover=\"hover(circle,$event)\"\n        @mouseout=\"hover(circle,$event)\" />\n         \n      <!-- show hashtag labels (once all memories are visible) -->\n      <g v-if=\"hashtagLabels && options.progress >= parsedMemories.length - 10\">\n        <g v-for=\"(link,i) in hashtagLabels\" :key=\"'label-'+i\" pointer-events=\"none\">\n          <line stroke=\"#FA5E2D\" stroke-width=\".5\" :x1=\"link.source.x\" :y1=\"link.source.y\" :x2=\"link.target.x\" :y2=\"link.target.y+1\" />\n          <text style=\"text-decoration: underline;\" font-weight=\"bold\" fill=\"#FA5E2D\" font-size=\"11\" :x=\"link.target.x\" :text-anchor=\"link.target.anchor\" :y=\"link.target.y\">{{link.target.text}}</text>\n        </g>\n      </g>\n    </g>\n\n\n    <g class=\"datePicker\" @click=\"$emit('toggleForm', formatDate(newMemory.date))\"\n     v-if=\"datePicker\"\n     :transform=\"`translate(${newMemory.position.x},0)`\"> <!-- can go to own component -->\n      <line y1=\"0\" :y2=\"options.dimensions.height\" x1=\"0\" x2=\"0\" stroke=\"#FA5E2D\" stroke-width=\"2px\"  stroke-dasharray=\"0\"/>\n      <circle r=\"40\" cx=\"0\" :cy=\"newMemory.position.y\" fill=\"#FA5E2D\" />\n      <!--<text x=\"0\" text-anchor=\"middle\" :y=\"(newMemory.position.y - 5)\">Click to add</text>-->\n      <text x=\"0\" text-anchor=\"middle\" :y=\"(newMemory.position.y)\">{{getRoughDate(newMemory.date)}}</text>\n    </g>\n\n    <g class=\"overlay\" v-if=\"options.overlay\">\n      <rect x=\"0\" y=\"0\" :width=\"options.dimensions.width\" :height=\"options.dimensions.height\" fill=\"black\" opacity=\".5\" pointer-events=\"none\"/>\n      <g v-if=\"currentMemory\">\n\n        <circle\n          r=20\n          :cx=\"currentMemory.x\"\n          :cy=\"currentMemory.y\"\n          fill=\"#FA5E2D\" />\n\n        <path\n          :d=\"currentMemory.connector\"\n          stroke-width=\"2\"\n          fill=\"none\"\n          stroke=\"#FA5E2D\"/>\n\n      </g>\n    </g>\n  </svg>\n</template>\n\n<script>\nimport Vue from 'vue'\nimport * as d3 from 'd3'\n//import {annotation, annotationCallout} from \"d3-svg-annotation\"\nimport lines from './lines'\n\nexport default {\n  components: {\n    lines,\n  },\n  data () {\n    return {\n      parseDate: d3.utcParse(\"%Y-%m-%d\"),\n      formatDate: d3.timeFormat(\"%Y-%m-%d\"),\n      lineGenerator: d3.line().x(d => d.x).y(d => d.y).curve(d3.curveBasis),\n      mounted: false,\n      force: null,\n      opacity: 0.8, //circle opacity when not hovered\n      forceDistance: 8, //distance of reactions to line\n      currentMemory: null, //when currently displaying a memory, pick the right one to highlight\n      newMemory: {\n        date: null,\n        show: false,\n        position: {x: -100, y: -100}, //start out of sight\n      },\n    }\n  },\n\n  props: {\n    options: Object,\n    hashtag: String,\n    cases: Array,\n    memories: Array,\n    datePicker: Boolean,\n\n  },\n\n  computed: {\n    parsedCases: function() {\n      return this.cases.map((c) => {\n        return {\n          dateString: c.d,\n          date: this.parseDate(c.d),\n          value: c.v,\n        }\n      })\n    },\n\n    scales: function() {\n      if(!this.parsedCases && this.memories) return null\n\n      let yDomain = [0,d3.max([50,d3.max(this.parsedCases, d=>d.value)])] //minimum of 50 cases to have a somewhat consistent layout\n      let xDomain = d3.extent(this.parsedCases, d=>d.date)\n      let radiusDomain = d3.extent(this.memories, d=>d.weight)\n\n      let x = d3.scaleTime().domain(xDomain).range([this.options.dimensions.left,this.options.dimensions.width-this.options.dimensions.right])\n      let y = d3.scaleLinear().domain(yDomain).range([this.options.dimensions.height-this.options.dimensions.bottom-this.options.dimensions.top,this.options.dimensions.top])\n      let radius = d3.scaleLinear().domain(radiusDomain).range([2,6])\n      \n      return {x: x, y: y, radius: radius}\n    },\n\n    parsedMemories: function() {\n      if(!this.memories) return null\n\n      this.scales //mention to force recomputation if dimensions change\n\n      return this.memories.map((memory,i) => {\n        let sign = (i%2) ? 1 : -1\n        memory.Date = this.parseDate(memory.date)\n        memory.x = this.scales.x(memory.Date)\n        memory.value = this.getLineElement(memory.date).value\n        memory.y = this.scales.y(memory.value) + this.forceDistance * sign\n        memory.radius = this.scales.radius(memory.weight)\n        memory.hashtag = (memory.comment.match(/#[a-z]+/gi)) ? (memory.comment.match(/#[a-z]+/gi))[0] : null \n\n        return memory\n      })\n    },\n\n    //generate force directed hashtags of X most weightened labels\n    hashtagLabels() {\n      if(!this.memories) return null\n      this.scales //mention to force recomputation if dimensions change\n\n      let nodes = []\n      let links = [] //\n\n      let memoriesWithTags = this.memories.filter(memory => memory.hashtag && !memory.inactive) //all active memories that have hashtags\n      \n      let latestHashtag = [...memoriesWithTags].sort((a,b) => b.Date - a.Date)[0] //the latest memory that has a hashtag\n      let selectedTags = memoriesWithTags.sort((a,b) => b.weight - a.weight).slice(0,10) //the X most weightened labels\n      selectedTags.push(latestHashtag) //the newest one (to put them into the view)\n\n      selectedTags.forEach((memory,i) => { //create node-link data\n          nodes.push({type: \"circle\", fx: memory.x, fy: memory.y}) //origin\n          nodes.push({type: \"label\", text: memory.hashtag}) //target\n          links.push({source: i*2, target: i*2+1}) //link the two\n        })\n\n        var simulation = d3.forceSimulation(nodes) //generate force directed simulation\n        .force('charge', d3.forceManyBody().strength(-0))\n        .force('link', d3.forceLink().links(links))\n        //.force('forceY', d3.forceY())\n        .force('collide', d3.forceCollide(node => {return (node.text) ? node.text.length * 2 : 50}))\n\n        for(let i = 0; i <= 200; i++) {\n          simulation.tick()\n        }\n\n        links.forEach(link => {\n          link.target.anchor = (link.target.x > link.source.x) ? \"start\" : \"end\"\n        })\n      return links\n\n    },\n  },\n\n  watch: {\n    parsedMemories: function(memories) {\n      this.releaseTheBees(memories)\n   },\n\n    hashtag: function(newHashtag){\n      if(!this.memories) return null\n      this.memories.forEach((memory,i) => {\n        if(newHashtag && !memory.comment.includes(newHashtag)) {\n          Vue.set(this.memories[i],'inactive',true)\n        } else {\n          Vue.set(this.memories[i],'inactive',false)\n        }\n      })\n    },\n\n    memories: function(arr) { //show circle on overlay after beeswarm changed\n      let c = arr.filter(e=>e.active)[0]\n      if(c) {\n        this.currentMemory = c\n         this.currentMemory.connector = `\n          M${c.x} ${c.y}\n          Q${(this.options.dimensions.width/2)} ${c.y}\n          ${(this.options.dimensions.width/2)} ${(10)}`;\n      }\n    }\n  },\n\n  async mounted() {\n    this.releaseTheBees(this.memories)\n    document.addEventListener('mousemove', this.onMouseMove)\n    this.mounted = true;\n  },\n\n  methods: {\n    releaseTheBees: function(memories) {\n      \n      this.force = d3.forceSimulation(memories)\n      .force('forceX', d3.forceX(memory => memory.x).strength(.1))\n      .force('forceY', d3.forceY(memory => memory.y).strength(.1))\n      .force('collide', d3.forceCollide(d => d.radius + .5))\n\n      for(let i = 0; i <= 20; i++) {\n        this.force.tick()\n      }\n    },\n\n    hover: function(memory,event) { //hovering circles\n      if(!this.datePicker) {  //disable hover when memory adding is in progress\n        let r = 10\n        let opacity = 1\n        if(event.type == 'mouseout') {\n          r = memory.weight\n          opacity = this.opacity\n       }\n       d3.select(event.target).transition(\"50\").attr(\"r\",r).attr(\"opacity\",opacity)\n      }\n    },\n\n    getLineElement: function(dateString) {\n      let valueOnMemoryDate = this.parsedCases.find(c => dateString == c.dateString)\n      return valueOnMemoryDate ? valueOnMemoryDate : null\n    },\n\n    getLineSegment: function(startDate,endDate) {\n      startDate = (typeof startDate === 'string') ? this.parseDate(startDate) : startDate\n      endDate = (typeof endDate === 'string') ? this.parseDate(endDate) : endDate\n      let segment = this.parsedCases.filter(c => //get parts of the caseLine that match current dates\n            (c.date < endDate && c.date > startDate) //forward movement\n            || (c.date > endDate && c.date < startDate) //backward movement\n          )\n      return segment\n    },\n\n    getRoughDate: function(date) {\n      if(!date) return null\n      \n      let rough = \"Late\"\n      if(date.getDate() <= 20) rough = \"Mid\"\n      if(date.getDate() <= 10) rough = \"Early\"\n      let month = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"][date.getMonth()]\n        \n      return rough+\" \"+month\n    },\n\n    onMouseMove: function(event) { //follow line\n      if(this.datePicker) {\n        if(event.clientX > this.scales.x.range()[0] && event.clientX < this.scales.x.range()[1]) { //check whether we are moving within vis boundaries to avoid errors\n          let date = this.scales.x.invert(event.clientX)\n          let dateString = this.formatDate(date)\n          let value = this.scales.y(this.getLineElement(dateString).value)\n          Vue.set(this.newMemory,'date',date) //also move circle\n          Vue.set(this.newMemory.position,'x',event.clientX) //also move circle\n          Vue.set(this.newMemory.position,'y',value)\n        }\n      }\n    },\n  },\n\n  /*updated: function() {\n    console.log(\"foo\")\n      this.force.tick()\n  },*/\n}\n</script>\n\n<style scoped>\n.datePicker {\n  cursor: pointer;\n}\n\n.datePicker text {\n  font-size: 12px;\n  pointer-events: none;\n}\n\ncircle.inactive {\n  opacity: .2 !important;\n  fill: grey !important;\n  pointer-events: none;\n}\n\n.datePicker text.strong {\n  font-weight: bold;\n}\n</style>"]}]}