{"remainingRequest":"/Users/tk/GitHub/corona-memories/client/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/tk/GitHub/corona-memories/client/src/components/vis.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/tk/GitHub/corona-memories/client/src/components/vis.vue","mtime":1615910686540},{"path":"/Users/tk/GitHub/corona-memories/client/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/corona-memories/client/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/tk/GitHub/corona-memories/client/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/corona-memories/client/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBWdWUgZnJvbSAndnVlJwppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycKLy9pbXBvcnQge2Fubm90YXRpb24sIGFubm90YXRpb25DYWxsb3V0fSBmcm9tICJkMy1zdmctYW5ub3RhdGlvbiIKaW1wb3J0IGxpbmVzIGZyb20gJy4vbGluZXMnCgpleHBvcnQgZGVmYXVsdCB7CiAgY29tcG9uZW50czogewogICAgbGluZXMsCiAgfSwKICBkYXRhICgpIHsKICAgIHJldHVybiB7CiAgICAgIHBhcnNlRGF0ZTogZDMudXRjUGFyc2UoIiVZLSVtLSVkIiksCiAgICAgIGZvcm1hdERhdGU6IGQzLnRpbWVGb3JtYXQoIiVZLSVtLSVkIiksCiAgICAgIGxpbmVHZW5lcmF0b3I6IGQzLmxpbmUoKS54KGQgPT4gZC54KS55KGQgPT4gZC55KS5jdXJ2ZShkMy5jdXJ2ZUJhc2lzKSwKICAgICAgZm9yY2U6IG51bGwsCiAgICAgIG9wYWNpdHk6IDAuOCwgLy9jaXJjbGUgb3BhY2l0eSB3aGVuIG5vdCBob3ZlcmVkCiAgICAgIGZvcmNlRGlzdGFuY2U6IDgsIC8vZGlzdGFuY2Ugb2YgcmVhY3Rpb25zIHRvIGxpbmUKICAgICAgY3VycmVudE1lbW9yeTogbnVsbCwgLy93aGVuIGN1cnJlbnRseSBkaXNwbGF5aW5nIGEgbWVtb3J5LCBwaWNrIHRoZSByaWdodCBvbmUgdG8gaGlnaGxpZ2h0CiAgICAgIG5ld01lbW9yeTogewogICAgICAgIGRhdGU6IG51bGwsCiAgICAgICAgc2hvdzogZmFsc2UsCiAgICAgICAgcG9zaXRpb246IHt4OiAtMTAwLCB5OiAtMTAwfSwgLy9zdGFydCBvdXQgb2Ygc2lnaHQKICAgICAgfSwKICAgIH0KICB9LAoKICBwcm9wczogewogICAgb3B0aW9uczogT2JqZWN0LAogICAgaGFzaHRhZzogU3RyaW5nLAogICAgY2FzZXM6IEFycmF5LAogICAgbWVtb3JpZXM6IEFycmF5LAogICAgZGF0ZVBpY2tlcjogQm9vbGVhbiwKCiAgfSwKCiAgY29tcHV0ZWQ6IHsKICAgIHBhcnNlZENhc2VzOiBmdW5jdGlvbigpIHsKICAgICAgcmV0dXJuIHRoaXMuY2FzZXMubWFwKChjKSA9PiB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIGRhdGVTdHJpbmc6IGMuZCwKICAgICAgICAgIGRhdGU6IHRoaXMucGFyc2VEYXRlKGMuZCksCiAgICAgICAgICB2YWx1ZTogYy52LAogICAgICAgIH0KICAgICAgfSkKICAgIH0sCgogICAgc2NhbGVzOiBmdW5jdGlvbigpIHsKICAgICAgaWYoIXRoaXMucGFyc2VkQ2FzZXMgJiYgdGhpcy5tZW1vcmllcykgcmV0dXJuIG51bGwKCiAgICAgIGxldCB5RG9tYWluID0gWzAsZDMubWF4KFs1MCxkMy5tYXgodGhpcy5wYXJzZWRDYXNlcywgZD0+ZC52YWx1ZSldKV0gLy9taW5pbXVtIG9mIDUwIGNhc2VzIHRvIGhhdmUgYSBzb21ld2hhdCBjb25zaXN0ZW50IGxheW91dAogICAgICBsZXQgeERvbWFpbiA9IGQzLmV4dGVudCh0aGlzLnBhcnNlZENhc2VzLCBkPT5kLmRhdGUpCiAgICAgIGxldCByYWRpdXNEb21haW4gPSBkMy5leHRlbnQodGhpcy5tZW1vcmllcywgZD0+ZC53ZWlnaHQpCgogICAgICBsZXQgeCA9IGQzLnNjYWxlVGltZSgpLmRvbWFpbih4RG9tYWluKS5yYW5nZShbdGhpcy5vcHRpb25zLmRpbWVuc2lvbnMubGVmdCx0aGlzLm9wdGlvbnMuZGltZW5zaW9ucy53aWR0aC10aGlzLm9wdGlvbnMuZGltZW5zaW9ucy5yaWdodF0pCiAgICAgIGxldCB5ID0gZDMuc2NhbGVMaW5lYXIoKS5kb21haW4oeURvbWFpbikucmFuZ2UoW3RoaXMub3B0aW9ucy5kaW1lbnNpb25zLmhlaWdodC10aGlzLm9wdGlvbnMuZGltZW5zaW9ucy5ib3R0b20tdGhpcy5vcHRpb25zLmRpbWVuc2lvbnMudG9wLHRoaXMub3B0aW9ucy5kaW1lbnNpb25zLnRvcF0pCiAgICAgIGxldCByYWRpdXMgPSBkMy5zY2FsZUxpbmVhcigpLmRvbWFpbihyYWRpdXNEb21haW4pLnJhbmdlKFsyLDZdKQogICAgICAKICAgICAgcmV0dXJuIHt4OiB4LCB5OiB5LCByYWRpdXM6IHJhZGl1c30KICAgIH0sCgogICAgcGFyc2VkTWVtb3JpZXM6IGZ1bmN0aW9uKCkgewogICAgICBpZighdGhpcy5tZW1vcmllcykgcmV0dXJuIG51bGwKCiAgICAgIHRoaXMuc2NhbGVzIC8vbWVudGlvbiB0byBmb3JjZSByZWNvbXB1dGF0aW9uIGlmIGRpbWVuc2lvbnMgY2hhbmdlCgogICAgICByZXR1cm4gdGhpcy5tZW1vcmllcy5tYXAoKG1lbW9yeSxpKSA9PiB7CiAgICAgICAgbGV0IHNpZ24gPSAoaSUyKSA/IDEgOiAtMQogICAgICAgIG1lbW9yeS5EYXRlID0gdGhpcy5wYXJzZURhdGUobWVtb3J5LmRhdGUpCiAgICAgICAgbWVtb3J5LnggPSB0aGlzLnNjYWxlcy54KG1lbW9yeS5EYXRlKQogICAgICAgIG1lbW9yeS52YWx1ZSA9IHRoaXMuZ2V0TGluZUVsZW1lbnQobWVtb3J5LmRhdGUpLnZhbHVlCiAgICAgICAgbWVtb3J5LnkgPSB0aGlzLnNjYWxlcy55KG1lbW9yeS52YWx1ZSkgKyB0aGlzLmZvcmNlRGlzdGFuY2UgKiBzaWduCiAgICAgICAgbWVtb3J5LnJhZGl1cyA9IHRoaXMuc2NhbGVzLnJhZGl1cyhtZW1vcnkud2VpZ2h0KQogICAgICAgIG1lbW9yeS5oYXNodGFnID0gKG1lbW9yeS5jb21tZW50Lm1hdGNoKC8jW2Etel0rL2dpKSkgPyAobWVtb3J5LmNvbW1lbnQubWF0Y2goLyNbYS16XSsvZ2kpKVswXSA6IG51bGwgCgogICAgICAgIHJldHVybiBtZW1vcnkKICAgICAgfSkKICAgIH0sCgogICAgLy9nZW5lcmF0ZSBmb3JjZSBkaXJlY3RlZCBoYXNodGFncyBvZiBYIG1vc3Qgd2VpZ2h0ZW5lZCBsYWJlbHMKICAgIGhhc2h0YWdMYWJlbHMoKSB7CiAgICAgIGlmKCF0aGlzLm1lbW9yaWVzKSByZXR1cm4gbnVsbAogICAgICB0aGlzLnNjYWxlcyAvL21lbnRpb24gdG8gZm9yY2UgcmVjb21wdXRhdGlvbiBpZiBkaW1lbnNpb25zIGNoYW5nZQoKICAgICAgbGV0IG5vZGVzID0gW10KICAgICAgbGV0IGxpbmtzID0gW10gLy8KCiAgICAgIGxldCBtZW1vcmllc1dpdGhUYWdzID0gdGhpcy5tZW1vcmllcy5maWx0ZXIobWVtb3J5ID0+IG1lbW9yeS5oYXNodGFnICYmICFtZW1vcnkuaW5hY3RpdmUpIC8vYWxsIGFjdGl2ZSBtZW1vcmllcyB0aGF0IGhhdmUgaGFzaHRhZ3MKICAgICAgCiAgICAgIGxldCBsYXRlc3RIYXNodGFnID0gWy4uLm1lbW9yaWVzV2l0aFRhZ3NdLnNvcnQoKGEsYikgPT4gYi5EYXRlIC0gYS5EYXRlKVswXSAvL3RoZSBsYXRlc3QgbWVtb3J5IHRoYXQgaGFzIGEgaGFzaHRhZwogICAgICBsZXQgc2VsZWN0ZWRUYWdzID0gbWVtb3JpZXNXaXRoVGFncy5zb3J0KChhLGIpID0+IGIud2VpZ2h0IC0gYS53ZWlnaHQpLnNsaWNlKDAsMTApIC8vdGhlIFggbW9zdCB3ZWlnaHRlbmVkIGxhYmVscwogICAgICBzZWxlY3RlZFRhZ3MucHVzaChsYXRlc3RIYXNodGFnKSAvL3RoZSBuZXdlc3Qgb25lICh0byBwdXQgdGhlbSBpbnRvIHRoZSB2aWV3KQoKICAgICAgc2VsZWN0ZWRUYWdzLmZvckVhY2goKG1lbW9yeSxpKSA9PiB7IC8vY3JlYXRlIG5vZGUtbGluayBkYXRhCiAgICAgICAgICBub2Rlcy5wdXNoKHt0eXBlOiAiY2lyY2xlIiwgZng6IG1lbW9yeS54LCBmeTogbWVtb3J5Lnl9KSAvL29yaWdpbgogICAgICAgICAgbm9kZXMucHVzaCh7dHlwZTogImxhYmVsIiwgdGV4dDogbWVtb3J5Lmhhc2h0YWd9KSAvL3RhcmdldAogICAgICAgICAgbGlua3MucHVzaCh7c291cmNlOiBpKjIsIHRhcmdldDogaSoyKzF9KSAvL2xpbmsgdGhlIHR3bwogICAgICAgIH0pCgogICAgICAgIHZhciBzaW11bGF0aW9uID0gZDMuZm9yY2VTaW11bGF0aW9uKG5vZGVzKSAvL2dlbmVyYXRlIGZvcmNlIGRpcmVjdGVkIHNpbXVsYXRpb24KICAgICAgICAuZm9yY2UoJ2NoYXJnZScsIGQzLmZvcmNlTWFueUJvZHkoKS5zdHJlbmd0aCgtMCkpCiAgICAgICAgLmZvcmNlKCdsaW5rJywgZDMuZm9yY2VMaW5rKCkubGlua3MobGlua3MpKQogICAgICAgIC8vLmZvcmNlKCdmb3JjZVknLCBkMy5mb3JjZVkoKSkKICAgICAgICAuZm9yY2UoJ2NvbGxpZGUnLCBkMy5mb3JjZUNvbGxpZGUobm9kZSA9PiB7cmV0dXJuIChub2RlLnRleHQpID8gbm9kZS50ZXh0Lmxlbmd0aCAqIDIgOiA1MH0pKQoKICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDw9IDIwMDsgaSsrKSB7CiAgICAgICAgICBzaW11bGF0aW9uLnRpY2soKQogICAgICAgIH0KCiAgICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+IHsKICAgICAgICAgIGxpbmsudGFyZ2V0LmFuY2hvciA9IChsaW5rLnRhcmdldC54ID4gbGluay5zb3VyY2UueCkgPyAic3RhcnQiIDogImVuZCIKICAgICAgICB9KQogICAgICByZXR1cm4gbGlua3MKCiAgICB9LAogIH0sCgogIHdhdGNoOiB7CiAgICBwYXJzZWRNZW1vcmllczogZnVuY3Rpb24obWVtb3JpZXMpIHsKICAgICAgdGhpcy5yZWxlYXNlVGhlQmVlcyhtZW1vcmllcykKICAgfSwKCiAgICBoYXNodGFnOiBmdW5jdGlvbihuZXdIYXNodGFnKXsKICAgICAgaWYoIXRoaXMubWVtb3JpZXMpIHJldHVybiBudWxsCiAgICAgIHRoaXMubWVtb3JpZXMuZm9yRWFjaCgobWVtb3J5LGkpID0+IHsKICAgICAgICBpZihuZXdIYXNodGFnICYmICFtZW1vcnkuY29tbWVudC5pbmNsdWRlcyhuZXdIYXNodGFnKSkgewogICAgICAgICAgVnVlLnNldCh0aGlzLm1lbW9yaWVzW2ldLCdpbmFjdGl2ZScsdHJ1ZSkKICAgICAgICB9IGVsc2UgewogICAgICAgICAgVnVlLnNldCh0aGlzLm1lbW9yaWVzW2ldLCdpbmFjdGl2ZScsZmFsc2UpCiAgICAgICAgfQogICAgICB9KQogICAgfSwKCiAgICBtZW1vcmllczogZnVuY3Rpb24oYXJyKSB7IC8vc2hvdyBjaXJjbGUgb24gb3ZlcmxheSBhZnRlciBiZWVzd2FybSBjaGFuZ2VkCiAgICAgIGxldCBjID0gYXJyLmZpbHRlcihlPT5lLmFjdGl2ZSlbMF0KICAgICAgaWYoYykgewogICAgICAgIHRoaXMuY3VycmVudE1lbW9yeSA9IGMKICAgICAgICAgdGhpcy5jdXJyZW50TWVtb3J5LmNvbm5lY3RvciA9IGAKICAgICAgICAgIE0ke2MueH0gJHtjLnl9CiAgICAgICAgICBRJHsodGhpcy5vcHRpb25zLmRpbWVuc2lvbnMud2lkdGgvMil9ICR7Yy55fQogICAgICAgICAgJHsodGhpcy5vcHRpb25zLmRpbWVuc2lvbnMud2lkdGgvMil9ICR7KDUwKX1gOwogICAgICB9CiAgICB9CiAgfSwKCiAgYXN5bmMgbW91bnRlZCgpIHsKICAgIHRoaXMucmVsZWFzZVRoZUJlZXModGhpcy5tZW1vcmllcykKICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Nb3VzZU1vdmUpCiAgfSwKCiAgbWV0aG9kczogewogICAgcmVsZWFzZVRoZUJlZXM6IGZ1bmN0aW9uKG1lbW9yaWVzKSB7CiAgICAgIAogICAgICB0aGlzLmZvcmNlID0gZDMuZm9yY2VTaW11bGF0aW9uKG1lbW9yaWVzKQogICAgICAuZm9yY2UoJ2ZvcmNlWCcsIGQzLmZvcmNlWChtZW1vcnkgPT4gbWVtb3J5LngpLnN0cmVuZ3RoKC4xKSkKICAgICAgLmZvcmNlKCdmb3JjZVknLCBkMy5mb3JjZVkobWVtb3J5ID0+IG1lbW9yeS55KS5zdHJlbmd0aCguMSkpCiAgICAgIC5mb3JjZSgnY29sbGlkZScsIGQzLmZvcmNlQ29sbGlkZShkID0+IGQucmFkaXVzICsgLjUpKQoKICAgICAgZm9yKGxldCBpID0gMDsgaSA8PSAyMDsgaSsrKSB7CiAgICAgICAgdGhpcy5mb3JjZS50aWNrKCkKICAgICAgfQogICAgfSwKCiAgICBob3ZlcjogZnVuY3Rpb24obWVtb3J5LGV2ZW50KSB7IC8vaG92ZXJpbmcgY2lyY2xlcwogICAgICBpZighdGhpcy5kYXRlUGlja2VyKSB7ICAvL2Rpc2FibGUgaG92ZXIgd2hlbiBtZW1vcnkgYWRkaW5nIGlzIGluIHByb2dyZXNzCiAgICAgICAgbGV0IHIgPSAxMAogICAgICAgIGxldCBvcGFjaXR5ID0gMQogICAgICAgIGlmKGV2ZW50LnR5cGUgPT0gJ21vdXNlb3V0JykgewogICAgICAgICAgciA9IG1lbW9yeS53ZWlnaHQKICAgICAgICAgIG9wYWNpdHkgPSB0aGlzLm9wYWNpdHkKICAgICAgIH0KICAgICAgIGQzLnNlbGVjdChldmVudC50YXJnZXQpLnRyYW5zaXRpb24oIjUwIikuYXR0cigiciIscikuYXR0cigib3BhY2l0eSIsb3BhY2l0eSkKICAgICAgfQogICAgfSwKCiAgICBnZXRMaW5lRWxlbWVudDogZnVuY3Rpb24oZGF0ZVN0cmluZykgewogICAgICBsZXQgdmFsdWVPbk1lbW9yeURhdGUgPSB0aGlzLnBhcnNlZENhc2VzLmZpbmQoYyA9PiBkYXRlU3RyaW5nID09IGMuZGF0ZVN0cmluZykKICAgICAgcmV0dXJuIHZhbHVlT25NZW1vcnlEYXRlID8gdmFsdWVPbk1lbW9yeURhdGUgOiBudWxsCiAgICB9LAoKICAgIGdldExpbmVTZWdtZW50OiBmdW5jdGlvbihzdGFydERhdGUsZW5kRGF0ZSkgewogICAgICBzdGFydERhdGUgPSAodHlwZW9mIHN0YXJ0RGF0ZSA9PT0gJ3N0cmluZycpID8gdGhpcy5wYXJzZURhdGUoc3RhcnREYXRlKSA6IHN0YXJ0RGF0ZQogICAgICBlbmREYXRlID0gKHR5cGVvZiBlbmREYXRlID09PSAnc3RyaW5nJykgPyB0aGlzLnBhcnNlRGF0ZShlbmREYXRlKSA6IGVuZERhdGUKICAgICAgbGV0IHNlZ21lbnQgPSB0aGlzLnBhcnNlZENhc2VzLmZpbHRlcihjID0+IC8vZ2V0IHBhcnRzIG9mIHRoZSBjYXNlTGluZSB0aGF0IG1hdGNoIGN1cnJlbnQgZGF0ZXMKICAgICAgICAgICAgKGMuZGF0ZSA8IGVuZERhdGUgJiYgYy5kYXRlID4gc3RhcnREYXRlKSAvL2ZvcndhcmQgbW92ZW1lbnQKICAgICAgICAgICAgfHwgKGMuZGF0ZSA+IGVuZERhdGUgJiYgYy5kYXRlIDwgc3RhcnREYXRlKSAvL2JhY2t3YXJkIG1vdmVtZW50CiAgICAgICAgICApCiAgICAgIHJldHVybiBzZWdtZW50CiAgICB9LAoKICAgIGdldFJvdWdoRGF0ZTogZnVuY3Rpb24oZGF0ZSkgewogICAgICBpZighZGF0ZSkgcmV0dXJuIG51bGwKICAgICAgCiAgICAgIGxldCByb3VnaCA9ICJMYXRlIgogICAgICBpZihkYXRlLmdldERhdGUoKSA8PSAyMCkgcm91Z2ggPSAiTWlkIgogICAgICBpZihkYXRlLmdldERhdGUoKSA8PSAxMCkgcm91Z2ggPSAiRWFybHkiCiAgICAgIGxldCBtb250aCA9IFsiSmFudWFyeSIsICJGZWJydWFyeSIsICJNYXJjaCIsICJBcHJpbCIsICJNYXkiLCAiSnVuZSIsICJKdWx5IiwgIkF1Z3VzdCIsICJTZXB0ZW1iZXIiLCAiT2N0b2JlciIsICJOb3ZlbWJlciIsICJEZWNlbWJlciJdW2RhdGUuZ2V0TW9udGgoKV0KICAgICAgICAKICAgICAgcmV0dXJuIHJvdWdoKyIgIittb250aAogICAgfSwKCiAgICBvbk1vdXNlTW92ZTogZnVuY3Rpb24oZXZlbnQpIHsgLy9mb2xsb3cgbGluZQogICAgICBpZih0aGlzLmRhdGVQaWNrZXIpIHsKICAgICAgICBpZihldmVudC5jbGllbnRYID4gdGhpcy5zY2FsZXMueC5yYW5nZSgpWzBdICYmIGV2ZW50LmNsaWVudFggPCB0aGlzLnNjYWxlcy54LnJhbmdlKClbMV0pIHsgLy9jaGVjayB3aGV0aGVyIHdlIGFyZSBtb3Zpbmcgd2l0aGluIHZpcyBib3VuZGFyaWVzIHRvIGF2b2lkIGVycm9ycwogICAgICAgICAgbGV0IGRhdGUgPSB0aGlzLnNjYWxlcy54LmludmVydChldmVudC5jbGllbnRYKQogICAgICAgICAgbGV0IGRhdGVTdHJpbmcgPSB0aGlzLmZvcm1hdERhdGUoZGF0ZSkKICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuc2NhbGVzLnkodGhpcy5nZXRMaW5lRWxlbWVudChkYXRlU3RyaW5nKS52YWx1ZSkKICAgICAgICAgIFZ1ZS5zZXQodGhpcy5uZXdNZW1vcnksJ2RhdGUnLGRhdGUpIC8vYWxzbyBtb3ZlIGNpcmNsZQogICAgICAgICAgVnVlLnNldCh0aGlzLm5ld01lbW9yeS5wb3NpdGlvbiwneCcsZXZlbnQuY2xpZW50WCkgLy9hbHNvIG1vdmUgY2lyY2xlCiAgICAgICAgICBWdWUuc2V0KHRoaXMubmV3TWVtb3J5LnBvc2l0aW9uLCd5Jyx2YWx1ZSkKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgfSwKCiAgLyp1cGRhdGVkOiBmdW5jdGlvbigpIHsKICAgIGNvbnNvbGUubG9nKCJmb28iKQogICAgICB0aGlzLmZvcmNlLnRpY2soKQogIH0sKi8KfQo="},{"version":3,"sources":["vis.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"vis.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <svg :width=\"options.dimensions.width\" :height=\"options.dimensions.height\">\n    \n    <lines\n      :dimensions=\"options.dimensions\"\n      :scales=\"scales\"\n      :cases=\"parsedCases\" />\n\n    <g v-if=\"force\" class=\"memories\"  transform=\"translate(0,0)\"> <!-- can go to component, actually.... -->\n      <circle\n        v-for=\"circle, i in parsedMemories.filter((e,i) => i < options.progress)\" :key=\"'circle-'+i\"\n        :cx=\"circle.x\"\n        :cy=\"circle.y\"\n        :class=\"{inactive: circle.inactive}\"\n        :r=\"circle.radius\"\n        fill=\"#FA5E2D\"\n        :opacity=\"opacity\"\n        @click=\"$emit('showMemory',circle)\"\n        @mouseover=\"hover(circle,$event)\"\n        @mouseout=\"hover(circle,$event)\" />\n         \n      <!-- show hashtag labels (once all memories are visible) -->\n      <g v-if=\"hashtagLabels && options.progress >= parsedMemories.length - 10\">\n        <g v-for=\"(link,i) in hashtagLabels\" :key=\"'label-'+i\" pointer-events=\"none\">\n          <line stroke=\"#FA5E2D\" stroke-width=\".5\" :x1=\"link.source.x\" :y1=\"link.source.y\" :x2=\"link.target.x\" :y2=\"link.target.y+1\" />\n          <text style=\"text-decoration: underline;\" font-weight=\"bold\" fill=\"#FA5E2D\" font-size=\"11\" :x=\"link.target.x\" :text-anchor=\"link.target.anchor\" :y=\"link.target.y\">{{link.target.text}}</text>\n        </g>\n      </g>\n    </g>\n\n\n    <g class=\"datePicker\" @click=\"$emit('toggleForm', formatDate(newMemory.date))\"\n     v-if=\"datePicker\"\n     :transform=\"`translate(${newMemory.position.x},0)`\"> <!-- can go to own component -->\n      <line y1=\"0\" :y2=\"options.dimensions.height\" x1=\"0\" x2=\"0\" stroke=\"#FA5E2D\" stroke-width=\"2px\"  stroke-dasharray=\"0\"/>\n      <circle r=\"40\" cx=\"0\" :cy=\"newMemory.position.y\" fill=\"#FA5E2D\" />\n      <!--<text x=\"0\" text-anchor=\"middle\" :y=\"(newMemory.position.y - 5)\">Click to add</text>-->\n      <text x=\"0\" text-anchor=\"middle\" :y=\"(newMemory.position.y)\">{{getRoughDate(newMemory.date)}}</text>\n    </g>\n\n    <g class=\"overlay\" v-if=\"options.overlay\">\n      <rect x=\"0\" y=\"0\" :width=\"options.dimensions.width\" :height=\"options.dimensions.height\" fill=\"black\" opacity=\".5\" pointer-events=\"none\"/>\n      <g v-if=\"currentMemory\">\n\n        <circle\n          r=20\n          :cx=\"currentMemory.x\"\n          :cy=\"currentMemory.y\"\n          fill=\"#FA5E2D\" />\n\n        <path\n          :d=\"currentMemory.connector\"\n          stroke-width=\"2\"\n          fill=\"none\"\n          stroke=\"#FA5E2D\"/>\n\n      </g>\n    </g>\n  </svg>\n</template>\n\n<script>\nimport Vue from 'vue'\nimport * as d3 from 'd3'\n//import {annotation, annotationCallout} from \"d3-svg-annotation\"\nimport lines from './lines'\n\nexport default {\n  components: {\n    lines,\n  },\n  data () {\n    return {\n      parseDate: d3.utcParse(\"%Y-%m-%d\"),\n      formatDate: d3.timeFormat(\"%Y-%m-%d\"),\n      lineGenerator: d3.line().x(d => d.x).y(d => d.y).curve(d3.curveBasis),\n      force: null,\n      opacity: 0.8, //circle opacity when not hovered\n      forceDistance: 8, //distance of reactions to line\n      currentMemory: null, //when currently displaying a memory, pick the right one to highlight\n      newMemory: {\n        date: null,\n        show: false,\n        position: {x: -100, y: -100}, //start out of sight\n      },\n    }\n  },\n\n  props: {\n    options: Object,\n    hashtag: String,\n    cases: Array,\n    memories: Array,\n    datePicker: Boolean,\n\n  },\n\n  computed: {\n    parsedCases: function() {\n      return this.cases.map((c) => {\n        return {\n          dateString: c.d,\n          date: this.parseDate(c.d),\n          value: c.v,\n        }\n      })\n    },\n\n    scales: function() {\n      if(!this.parsedCases && this.memories) return null\n\n      let yDomain = [0,d3.max([50,d3.max(this.parsedCases, d=>d.value)])] //minimum of 50 cases to have a somewhat consistent layout\n      let xDomain = d3.extent(this.parsedCases, d=>d.date)\n      let radiusDomain = d3.extent(this.memories, d=>d.weight)\n\n      let x = d3.scaleTime().domain(xDomain).range([this.options.dimensions.left,this.options.dimensions.width-this.options.dimensions.right])\n      let y = d3.scaleLinear().domain(yDomain).range([this.options.dimensions.height-this.options.dimensions.bottom-this.options.dimensions.top,this.options.dimensions.top])\n      let radius = d3.scaleLinear().domain(radiusDomain).range([2,6])\n      \n      return {x: x, y: y, radius: radius}\n    },\n\n    parsedMemories: function() {\n      if(!this.memories) return null\n\n      this.scales //mention to force recomputation if dimensions change\n\n      return this.memories.map((memory,i) => {\n        let sign = (i%2) ? 1 : -1\n        memory.Date = this.parseDate(memory.date)\n        memory.x = this.scales.x(memory.Date)\n        memory.value = this.getLineElement(memory.date).value\n        memory.y = this.scales.y(memory.value) + this.forceDistance * sign\n        memory.radius = this.scales.radius(memory.weight)\n        memory.hashtag = (memory.comment.match(/#[a-z]+/gi)) ? (memory.comment.match(/#[a-z]+/gi))[0] : null \n\n        return memory\n      })\n    },\n\n    //generate force directed hashtags of X most weightened labels\n    hashtagLabels() {\n      if(!this.memories) return null\n      this.scales //mention to force recomputation if dimensions change\n\n      let nodes = []\n      let links = [] //\n\n      let memoriesWithTags = this.memories.filter(memory => memory.hashtag && !memory.inactive) //all active memories that have hashtags\n      \n      let latestHashtag = [...memoriesWithTags].sort((a,b) => b.Date - a.Date)[0] //the latest memory that has a hashtag\n      let selectedTags = memoriesWithTags.sort((a,b) => b.weight - a.weight).slice(0,10) //the X most weightened labels\n      selectedTags.push(latestHashtag) //the newest one (to put them into the view)\n\n      selectedTags.forEach((memory,i) => { //create node-link data\n          nodes.push({type: \"circle\", fx: memory.x, fy: memory.y}) //origin\n          nodes.push({type: \"label\", text: memory.hashtag}) //target\n          links.push({source: i*2, target: i*2+1}) //link the two\n        })\n\n        var simulation = d3.forceSimulation(nodes) //generate force directed simulation\n        .force('charge', d3.forceManyBody().strength(-0))\n        .force('link', d3.forceLink().links(links))\n        //.force('forceY', d3.forceY())\n        .force('collide', d3.forceCollide(node => {return (node.text) ? node.text.length * 2 : 50}))\n\n        for(let i = 0; i <= 200; i++) {\n          simulation.tick()\n        }\n\n        links.forEach(link => {\n          link.target.anchor = (link.target.x > link.source.x) ? \"start\" : \"end\"\n        })\n      return links\n\n    },\n  },\n\n  watch: {\n    parsedMemories: function(memories) {\n      this.releaseTheBees(memories)\n   },\n\n    hashtag: function(newHashtag){\n      if(!this.memories) return null\n      this.memories.forEach((memory,i) => {\n        if(newHashtag && !memory.comment.includes(newHashtag)) {\n          Vue.set(this.memories[i],'inactive',true)\n        } else {\n          Vue.set(this.memories[i],'inactive',false)\n        }\n      })\n    },\n\n    memories: function(arr) { //show circle on overlay after beeswarm changed\n      let c = arr.filter(e=>e.active)[0]\n      if(c) {\n        this.currentMemory = c\n         this.currentMemory.connector = `\n          M${c.x} ${c.y}\n          Q${(this.options.dimensions.width/2)} ${c.y}\n          ${(this.options.dimensions.width/2)} ${(50)}`;\n      }\n    }\n  },\n\n  async mounted() {\n    this.releaseTheBees(this.memories)\n    document.addEventListener('mousemove', this.onMouseMove)\n  },\n\n  methods: {\n    releaseTheBees: function(memories) {\n      \n      this.force = d3.forceSimulation(memories)\n      .force('forceX', d3.forceX(memory => memory.x).strength(.1))\n      .force('forceY', d3.forceY(memory => memory.y).strength(.1))\n      .force('collide', d3.forceCollide(d => d.radius + .5))\n\n      for(let i = 0; i <= 20; i++) {\n        this.force.tick()\n      }\n    },\n\n    hover: function(memory,event) { //hovering circles\n      if(!this.datePicker) {  //disable hover when memory adding is in progress\n        let r = 10\n        let opacity = 1\n        if(event.type == 'mouseout') {\n          r = memory.weight\n          opacity = this.opacity\n       }\n       d3.select(event.target).transition(\"50\").attr(\"r\",r).attr(\"opacity\",opacity)\n      }\n    },\n\n    getLineElement: function(dateString) {\n      let valueOnMemoryDate = this.parsedCases.find(c => dateString == c.dateString)\n      return valueOnMemoryDate ? valueOnMemoryDate : null\n    },\n\n    getLineSegment: function(startDate,endDate) {\n      startDate = (typeof startDate === 'string') ? this.parseDate(startDate) : startDate\n      endDate = (typeof endDate === 'string') ? this.parseDate(endDate) : endDate\n      let segment = this.parsedCases.filter(c => //get parts of the caseLine that match current dates\n            (c.date < endDate && c.date > startDate) //forward movement\n            || (c.date > endDate && c.date < startDate) //backward movement\n          )\n      return segment\n    },\n\n    getRoughDate: function(date) {\n      if(!date) return null\n      \n      let rough = \"Late\"\n      if(date.getDate() <= 20) rough = \"Mid\"\n      if(date.getDate() <= 10) rough = \"Early\"\n      let month = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"][date.getMonth()]\n        \n      return rough+\" \"+month\n    },\n\n    onMouseMove: function(event) { //follow line\n      if(this.datePicker) {\n        if(event.clientX > this.scales.x.range()[0] && event.clientX < this.scales.x.range()[1]) { //check whether we are moving within vis boundaries to avoid errors\n          let date = this.scales.x.invert(event.clientX)\n          let dateString = this.formatDate(date)\n          let value = this.scales.y(this.getLineElement(dateString).value)\n          Vue.set(this.newMemory,'date',date) //also move circle\n          Vue.set(this.newMemory.position,'x',event.clientX) //also move circle\n          Vue.set(this.newMemory.position,'y',value)\n        }\n      }\n    },\n  },\n\n  /*updated: function() {\n    console.log(\"foo\")\n      this.force.tick()\n  },*/\n}\n</script>\n\n<style scoped>\n.datePicker {\n  cursor: pointer;\n}\n\n.datePicker text {\n  font-size: 12px;\n  pointer-events: none;\n}\n\ncircle.inactive {\n  opacity: .2 !important;\n  fill: grey !important;\n  pointer-events: none;\n}\n\n.datePicker text.strong {\n  font-weight: bold;\n}\n</style>"]}]}