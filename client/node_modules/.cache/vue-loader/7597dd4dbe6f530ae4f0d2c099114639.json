{"remainingRequest":"/Users/tk/GitHub/corona-memories/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/tk/GitHub/corona-memories/src/components/vis.vue?vue&type=style&index=0&id=91b57380&scoped=true&lang=css&","dependencies":[{"path":"/Users/tk/GitHub/corona-memories/src/components/vis.vue","mtime":1612973798638},{"path":"/Users/tk/GitHub/corona-memories/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/corona-memories/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/tk/GitHub/corona-memories/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/tk/GitHub/corona-memories/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/tk/GitHub/corona-memories/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgpwYXRoIHsKICBmaWxsOiBub25lOwogIHN0cm9rZTogd2hpdGU7Cn0K"},{"version":3,"sources":["vis.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwJA;AACA;AACA;AACA","file":"vis.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <svg width=\"700\" height=\"1000\">\n    <defs>\n      <filter id=\"f1\"><feGaussianBlur in=\"SourceGraphic\" :stdDeviation=\"0\" /></filter>\n    </defs>\n\n    <g class=\"lines\" v-if=\"countries\">\n      <path v-for=\"country,i in countries\" :key=\"i\" :d=\"country.line\" filter=\"url(#f1)\" />\n    </g>\n\n    <g class=\"reactions\" v-if=\"reactions\" transform=\"translate(0,0)\">\n      <circle v-for=\"reaction, j in reactions\" :key=\"j\" :cx=\"reaction.x\" :cy=\"reaction.y\" :opacity=\"opacity\" :r=\"reaction.weight\" fill=\"#AFFE06\" @mouseover=\"hover(reaction,$event)\" @mouseout=\"hover(reaction,$event)\" />\n    </g>\n  </svg>\n</template>\n\n<script>\nimport * as d3 from 'd3'\n\nexport default {\n components: {\n },\n\n\n data () {\n   return {\n     mounted: false,\n     opacity: .7,\n     metric: 'relative',\n     csv: null,\n   }\n },\n\n\n computed: {\n   scales: function() {\n     if(!this.csv) return null\n     let yDomain = [0,d3.max(this.csv, d=>+d[this.metric])]\n     let xDomain = d3.extent(this.csv, d=>d.date)\n     let x = d3.scaleTime().domain(xDomain).range([50,650])\n     let y = d3.scaleLinear().domain(yDomain).range([400,50])\n\n     return {x: x, y: y}\n   },\n\n   reactions: function(){\n     if(!this.countries) return false\n\n     let formatTime = d3.timeFormat(\"%m/%d/%y\")\n     let reactionArr = [] //create sample reactions\n     Object.keys(this.countries).forEach(country => {\n       d3.range(500).forEach(() => {\n         let date = this.getRandomDate(this.scales.x.domain())\n         reactionArr.push({\n           date: date,\n           value: this.countries[country].cases.find(c => formatTime(c.date) == formatTime(date))[this.metric],\n           comment: \"foobar\",\n           weight: Math.floor(Math.random()*5),\n           country: country,\n         })\n       })\n     })\n\n     /*reactionArr.forEach(reaction => {\n       reaction.xx = this.scales.x(reaction.date)\n       reaction.yy = this.scales.y(reaction.value)\n     })*/\n\n     let force = d3.forceSimulation(reactionArr)\n      //.force('charge', d3.forceManyBody().strength(10))\n      //.force('center', d3.forceCenter(0,0))\n\n      //calculate first, then use straight values here\n      //.force('forceX', d3.forceX(reaction => reaction.xx).strength(1))\n      //.force('forceY', d3.forceY(reaction => reaction.yy).strength(2))\n\n      //no pre-calculation, but dont have original values here\n      //.force('forceX', d3.forceX(reaction => this.scales.x(reaction.date)).strength(1))\n      //.force('forceY', d3.forceY(reaction => this.scales.y(reaction.value) ).strength(2))\n\n      //deviate with modulo\n      .force('forceX', d3.forceX(reaction => this.scales.x(reaction.date)).strength(.1))\n      .force('forceY', d3.forceY((reaction,i) => this.scales.y(reaction.value) + (-8 + (i%2)*10)).strength(.1))\n      .force('collide', d3.forceCollide(d => d.weight))\n\n      for (let i = 0; i < reactionArr.length; ++i) {\n        //console.log(reactionArr[i])\n         force.tick()\n       }\n\n       console.log(force.nodes())\n\n     return force.nodes()\n\n   },\n\n   countries: function() {\n     if(!this.csv || !this.scales) return false\n\n     const lineGenerator = d3.line()\n      .x(d => this.scales.x(d.date))\n      .y(d => this.scales.y(d[this.metric]))\n\n    let countriesMap = d3.group(this.csv, d => d.country)\n    let countriesObj = Object.fromEntries(countriesMap)\n    Object.keys(countriesObj).map(key => {\n      countriesObj[key] = {\n        cases: countriesObj[key],\n        line: lineGenerator(countriesObj[key])\n      }\n    })\n    return countriesObj\n   },\n },\n\n created() {\n   const parseDate = d3.utcParse(\"%m/%d/%y\")\n   d3.csv('data.csv').then(d => {\n     this.csv = d.map(row => {\n       row.date = parseDate(row.date)\n       return row\n     })\n     .filter(d=> d.country == \"Germany\")\n   })\n\n },\n\n mounted() {\n   this.mounted = true\n },\n\n methods: {\n   getRandomDate: function(extent) {\n     let date = new Date(extent[0].getTime() + Math.random() * (extent[1].getTime() - extent[0].getTime()))\n     date.setHours(0,0,0)\n     return date\n   },\n\n   hover: function(reaction,event) {\n     let r = 7\n     let opacity = 1\n     if(event.type == 'mouseout') {\n       r = reaction.weight\n       opacity = this.opacity\n     }\n     d3.select(event.target).transition().attr(\"r\",r).attr(\"opacity\",opacity)\n   }\n }\n}\n</script>\n\n<style scoped>\n  path {\n    fill: none;\n    stroke: white;\n  }\n</style>\n"]}]}